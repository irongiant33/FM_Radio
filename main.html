<html>
    <head>
	<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
	<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
        <title> RTLSDR - FM Radio Decoding </title>
    </head>
    <body>
        <a href="../main.html"> Back to the main page </a>
        <br>
	
	<h1> Math behind FM Radio </h1>
	<p>
	The purpose of FM radio is to capture a voice signal, like a song, and transmit it to listeners that are far away from where the voice signal originates.
	The problem with voice is that is inherently very low frequency: 500 to 15000 Hz. If we have a digital voice signal that we want to transmit, it would require 
	an antenna nearly 5000m long (if you're using a quarter wave antenna)! 
	</p>
	<p>
	The solution is to modulate our voice signal onto a higher frequency carrier, let's say 
	94.5MHz, the frequency of my favorite rock station. Using the equation \(c=\lambda f\) we find that the wavelength of that carrier is ~3m. If we use a quarter wave 
	antenna, that becomes a much more reasonably 75cm that we can easily put in a car or radio receiver. 
	</p>
	<p>
	So I glossed over the key principle of FM radio just then. I said our solution is to modulate our voice signal onto a higher frequency carrier. How do you modulate something?
	We know the wave equation is \(V(t) = A sin(2\pi f t)\ + \phi).  \(V(t)\) represents the voltage of our digital signal over time, \(A\) represents the amplitude of our signal,
	\(f\) represents the frequency of our signal, and \(\phi\) represents the phase of our signal. We can control the amplitude, frequency, and phase, so we have the option to modulate
	any of these three quantities (really just two though because frequency and phase are one in the same). We'll denote the carrier signal with \(V_c(t) = A_c sin(2\pi f_c t) + \phi_c\), a simple sinusoid with one frequency. Our voice signal that we want to 
	modulate is a little more complicated because it is a combination of multiple signals of different frequencies and varying amplitudes. We'll represent our voice signal with \(V_s(t)\).
	</p>
	<h2> AM </h2>
	<p>
	Recognizing that I want to explain FM modulation, I actually want to start with AM because it is a little simpler. To modulate the amplitude we want the amplitude of our transmitted signal
	to vary according to the voltage level of our carrier wave. If the carrier voltage level is low, I want a low amplitude, and if the carrier voltage level is high, I want a high amplitude. We
	can represent this mathematically by \(A = A_c + V_s(t)\) where \(A\) is the amplitude of the signal we want ot transmit. We simply substitute this back into our carrier wave equation and yield
	\(V_c(t) = (A_c + V_s(t))sin(2\pi f_c t + \phi)\) and voila we have an amplitude modulated signal.
	</p>
	<h2> FM </h2>
	<p>
	The concept for FM is the same. We have to add a value to \(f_c\), but the trick is it has to be a frequency term. It isn't as straightforward as amplitude where we can just add our voice signal 
	to the amplitude to get AM. Instead, we introduce a new term \(\delta f\) which is the frequency swing. The frequency swing represents how much the carrier frequency will increase or decrease from
	its nominal value (usually the carrier frequency). This should be the maximum swing, so that \(B = 2\delta f\) where \(B\) is the bandwidth of the signal unless the highest frequency in our modulated signal is greater than the frequency swing (we'll cover this later in modulation index). Now we must include \(V_s(t)\) in our expression somehow in order to 
	actually modulate the frequency. We will express it as a ratio in order to cancel the voltage terms: \(\beta (t) = \frac{V_s(t)}{max(V_s(t))}\). This expression puts the instantaneous voltage value of the 
	voice signal as a ratio of -1 to 1 of the maximum voltage level of our voice. Therefore, the frequency term now becomes \(f = f_c + \delta f \beta (t)\).
	</p>
	<p>
	Where is was evident in the amplitude modulation case to just add our modulated signal to the amplitude of the carrier before amplifying the base sinusoid, it is not as trivial to add a frequency
	ratio to the base carrier sinusoid. I am not sure why the following is not the correct wave expression: \(V_c(t) = A sin(2\pi (f_c+\delta f \frac{V_s(t)}{max(V_s(t))}) t + \phi_c)\). All of the units are appropriate
	but it doesn't match what I have found in textbooks and <a href="https://en.wikipedia.org/wiki/Frequency_modulation"> online </a>. The instantaneous frequency expression below isn't much different from mine other
	than the modulation index. Maybe my expression is also correct, but writing it out like it is below lets you easily visualize the modulation index. I think the expressions are pretty much equal except for a phase shift.
	</p>
	<p>
	We will take a step back and let \(V_c(t) = A sin(2\pi \int f_m(\tau) d\tau) \) where \(f_m(\tau) = \frac{1}{2\pi}\frac{d\phi_m}{dt}\) is the instantaneous frequency and the \(m\) subnote defines the modulated signal. As above, we said the frequency of the modulated signal
	\(f(\tau) = f_c + \delta f \beta(t) \) so we can substitute and simplify to the following: \(V_c(t) = A sin(2\pi f_c t + 2\pi \delta f \int \beta(\tau) d\tau) \).
	<p>
	To simplify, we will pretend that our signal has only a single frequency component and an amplitude of 1: \(V_s(t) = cos(2\pi f_s t)\). This allows the right side of the sum to simplify to \(2\pi \delta f \frac{sin(2\pi f_s t}{2\pi f_s}\). As you can see, we now have the \(\frac{\delta f}{f_s}\) term which
	is known as the modulation index. If the frequency swing is smaller than the largest frequency in the signal, then the modulated signal is considered to be Narrow FM. If it is larger, then the modulated signal is considered to be wideband FM. If the amplitude of the modulated signal is something other than 1, 
	then you multiply the frequency swing by the amplitude and compare to the highest frequency in the baseband signal. 
	</p>
	<h2> Upconversion/Downconversion</h2>
	<p>
	To understand the upconversion component of FM, it is best to first imagine what is going on in the frequency dimension of FM radio. We have a carrier signal with high frequency impulses (for the sake of argument). Our voice
	signal is represented by a set of low frequencies. Imagine our voice signal as a rectangle with one end at 0 Hz and the other at 15kHz. We are taking our low frequency modulated voice signal and convolving it with
	the higher frequency carrier such that the output resembles two rectangles with half the height centered around the positive and negative carrier frequencies. If we performed a convolution of the signals in the
	frequency domain, the equivalent operation in the time domain is multiplication. That long explanation was just to tell you there are effectively two things going on in this equation: frequency upconversion by multiplying the time domain signals, and modulation of our voice.
	</p>
	<p>
	Let \(x=2\pi f_c t + \phi_c\) and \(y=2\pi\delta f\beta (t) +\phi\).
	\[V_m(t) = A_c cos(x) A_s cos(y)\]
	\[V_m(t) = A_c A_s (\frac{e^{jx}+e^{-jx})}{2})(\frac{e^{jy}+e^{-jy})}{2})\]
	\[V_m(t) = \frac{A_c A_s}{4}(e^{jx}e^{jy}+e^{jx}e^{-jy}+e^{-jx}e^{jy}+e^{-jx}e^{-jy})\]
	\[V_m(t) = \frac{A_c A_s}{4}(e^{j(x+y)} + e^{j(x-y)} + e^{-j(x-y)} + e^{-j(x+y)})\]
	\[V_m(t) = \frac{A_c A_s}{2}(\frac{e^{j(x+y)}+e^{-j(x+y)}}{2} + \frac{e^{j(x-y)}+e^{-j(x-y)}}{2})\]
	\[V_m(t) = \frac{A_c A_s}{2}(cos(x+y) + cos(x-y))\]
	</p>
	<p>
	Equation 2 is simplified by euler's formula. The resulting expression in equation 5 and 6 shows that we have frequency peaks spaced \(\delta f\) apart from the carrier
	frequency peaks in both the positive and negative frequency dimension. You can also verify this with trig identities. In practice, our \(\beta (t)\) value will fluctuate between -1 and 1, creating a rectangle centered
	at these carrier frequencies.
	</p>
	<p>
	Downconversion performs the opposite operation as upconversion. In order to extract the voice signal from an FM wave we convolve it with the carrier signal in the frequency dimension
	which means multiplying it with the carrier signal in the time dimension. Draw the convolution out on a piece of paper first and then verify it with math:
	\[V_d(t) = V_m(t) V_c(t)\]
	\[V_d(t) = \frac{A_c A_s}{2}(cos(x+y) + cos(x-y)) A_c cos(x)\]
	\[V_d(t) = \frac{A_c^2 A_s}{2}(\frac{e^{j(x+y)}+e^{-j(x+y)}}{2} + \frac{e^{j(x-y)}+e^{-j(x-y)}}{2})(\frac{e^{jx}+e^{-jx}}{2})\]
	\[V_d(t) = \frac{A_c^2 A_s}{8}(e^{j(x+y)}e^{jx} + e^{j(x+y)}e^{-jx} + e^{-j(x+y)}e^{jx} + e^{-j(x+y)}e^{-jx} + e^{j(x-y)}e^{jx} + e^{j(x-y)}e^{-jx} + e^{-j(x-y)}e^{jx} + e^{-j(x-y)}e^{-jx})\]
	\[V_d(t) = \frac{A_c^2 A_s}{8}(e^{j(2x+y)} + e^{jy} + e^{-jy} + e^{-j(2x+y)} + e^{j(2x-y)} + e^{-jy} + e^{jy} + e^{-j(2x-y)})\]
	\[V_d(t) = \frac{A_c^2 A_s}{4}(\frac{e^{j(2x+y)}+e^{-j(2x+y)}}{2} + e^{jy} + e^{-jy} + \frac{e^{j(2x-y)}+e^{-j(2x-y)}}{2})\]
	\[V_d(t) = \frac{A_c^2 A_s}{4}(cos(2x+y) + cos(2x-y)) + \frac{A_c^2 A_s}{2}(\frac{e^{jy}+e^{-jy}}{2})\]
	\[V_d(t) = \frac{A_c^2 A_s}{4}(cos(2x+y) + cos(2x-y)) + \frac{A_c^2 A_s}{2} cos(y)\]
	</p>
	<p>
	Now we have two high frequency signals (two times as high as the original carrier) as well as the baseband signal. You can also verify this with trig identities. 
	</p>
	
	<h2> Demodulation </h2>
	<p>
	To actually perform the demodulation you used to need dedicated circuitry such as a slope detector, Foster-Seely discriminator, or ratio detector. The downside of this is that the circuits required a transformer which
	makes it hard to build on a small integrated circuit (IC). Instead, quadrature detectors and phase-locked loops (PLL) are used. Chapter 6 in the 9th edition of Modern Electronic Communication by Beasley and Miller goes into great detail on
	these topics. 
	
	<h2> Quadrature Detector </h2>
	<p>
	A quadrature detector works by using XOR logic with two signal inputs. The signal inputs are just two different phase shifted versions of the IF signal (the received signal after downconversion, filtering, and amplification). 
	The first input is not phase shifted and the second input is phase shifted such that the downconverted carrier frequency is 90 degrees offset from the first input (hence the term quadrature detector). In the designed I learned about, 
	the quadrature detector was preceeded by a limiter to control the amplitude of the IF signal in order to remove any unwanted amplitude modulation due to noise. Input 2 was phase shifted by tuning values in a RLC circuit. 
	</p>
	<p>
	There is a low pass filter (RC) circuit at the output of the XOR gate. What happens is the phase shift caused by a change in frequency alters the width of the output pulse by shifting the input pulses slightly. The pulse width of the output
	is directly proportional to the phase difference. Using the average level from the output of the RC circuit, you get a demodulated real valued signal. 
	</p>
	<h2> PLL </h2>
	<p>
	The phased-lock loop is a way of taking the IF input into a control feedback loop to produce the FM demodulated signal. It would probably be easiest to look up a picture of a PLL, but the three components in the loop are the phase comparator, low pass filter, and voltage controlled
	oscillator. The loop works by comparing the VCO signal to the input signal in the phase comparator. The difference in phase between the two signals is sent out of the phase comparator as an error signal to the low pass filter and then output as the demodulated signal.
	The filtered error also is fed back into the VCO to either increase or decrease the frequency of the signal.
	</p>
	<h3> Phase Detector </h3>
	<p>
	The phase detector operation is to determine the difference between the phase of the input FM signal and the output of the VCO. This error signal is sent to the low pass filter. The most important aspect here is that 
	the greatest phase change between two samples cannot be greater than \(\pi /2\). If this was the case, the phase change would appear to be something that it actually isn't. Take the following example:
	Sample 1: \[0 [rad] \]
	Sample 2: \[\pi /4 [rad]\]
	Sample 3: \[\pi / 2 [rad]\]
	Given the phase of these 3 samples, what is the phase change (assuming a constant signal and sample frequency)? Instinct might tell you it is \(\pi /4\). That would be possible. But so would \(\pi /4 + 2\pi N\) where \(N\) is any integer. How can we tell for certain which frequency
	it actually is? The only thing we can assume is that the phase change is \(\pi /4\) and that the signal frequency would be \(\frac{\Delta \phi}{2\pi f_s}\) where \(\Delta \phi\) is the change in phase between samples. A phase change of exactly \(\pi\) between samples should correspond
	to the maximum frequency we can sample, which according to Nyquist, is 2 times our sampling frequency. In the case of some of the radio captures, our sample frequency was 2.5MHz, so a phase change of \(\pi\) corresponds to a frequency of 1.25 MHz and a phase change of \(-\pi\) corresponds
	to a frequency of -1.25 MHz (as long as our 0 Hz signal corresponds to the tuned downconverted frequency).
	</p>
	<p>
	Thus, this is the function of the PLL. If the VCO outputs 0 Hz and our input signal is 1.25MHz, the error signal is \(\pi\). The VCO sees this error signal and starts to increase its frequency to 1.25MHz. If the input frequency matches the VCO, we get no error signal and the VCO doesn't change
	frequency. A decrease in the input frequency's signal will correspond to a negative phase shift (assume the input signal went back to 0Hz while the VCO is still 1.25MHz, we would get a \(-\pi\) phase shift) and the VCO would start decreasing its frequency. 
	
	</p>
	<h3> Low Pass Filter </h3>
	Given the voltage of the error signal, the low pass filter models a simple RC circuit to determine the filtered output voltage level. You can model the output voltage with a first order differential equation:
	Kirchoff's Voltage Law: \[V_i(t) = i(t)R + \frac{q}{C}\]
	Divide by \(R\): \[i(t) + \frac{q}{RC} = \frac{V_i(t)}{R}\]
	Take the derivative w.r.t. time: \[\frac{di(t)}{dt} + \frac{i(t)}{RC} = \frac{1}{R}\frac{dV_i(t)}{dt}\]
	Multiply the integrating factor \(\mu(t)\): \[i'(t)\mu(t)+\frac{i(t)}{RC}\mu(t) = \frac{V_i'(t)}{R}\mu(t)\]
	Let's let \(\mu(t)*\frac{1}{RC} = \mu'(t)\): \[i'(t)\mu(t)+i(t)\mu'(t) = \frac{V_i'(t)}{R}\mu(t)\]
	The left side of the equation is equivalent to the product rule, so let's substitute: \[(i(t)\mu(t))' = \frac{V_i'(t)}{R}\mu(t)\]
	Integrate both sides with respect to time, with \(c\) as a constant: \[i(t)\mu(t) = \frac{1}{R}\int V_i'(t)\mu(t)dt + c\]
	Rearranging to solve for the current, we get (1): \[i(t) = \frac{\frac{1}{R}\int V_i'(t)\mu(t)dt + c}{\mu(t)}\]
	Now let's solve for the integrating factor \(\mu(t)\): \[\frac{\mu(t)}{RC} = \mu'(t)\]
	Divide both sides by \(\mu(t)\): \[\frac{1}{RC} = \frac{\mu'(t)}{\mu(t)}\]
	The right hand side is equivalent to \((ln(\mu(t))'\) so substitute: \[\frac{1}{RC} = [ln(\mu(t))]'\]
	Integrate with respect to time, where \(k\) is another arbitrary constant: \[\frac{1}{RC}\int dt = ln(\mu(t)) + k\]
	Rearrange and log roll: \[\mu(t) = e^{\frac{t}{RC} + k}\]
	Bring \(k\) down from the exponent since it is a constant: \[\mu(t) = ke^{\frac{t}{RC}}\]
	Substitute back into (1): \[i(t) = \frac{\frac{k}{R}\int V_i'(t) e^{\frac{t}{RC}}dt + c}{ke^{\frac{t}{RC}}}\]
	Now we can cancel \(k\) in the left part of the sum with the denominator, and the constant \(c\) can absorb \(k\): \[\frac{\frac{1}{R}\int V_i'(t)e^{\frac{t}{RC}}dt + c}{e^{\frac{t}{RC}}}\]
	
	The only confusing thing about the above equation is that our ADC samples are discrete time samples of the input voltage, not a continuous signal. It wouldn't make any sense to try and integrate our
	samples, the above equation is really only useful in the continuous time (analog) domain. The way to apply the same low pass filter in a digital setting we will implement the infinite impulse response (IIR)
	filter. Thankfully, our RC circuit analysis did not entirely go to waste. 
	Kirchoff's Voltage Law says: \[V_i[n] = i[n]R + V_o[n]\]
	we rearrange to get: \[V_i[n]-V_o[n] = i[n]R\]
	we know that the current over the resistor and the capacitor is the same so: \[i[n] = \frac{q[n]-q[n-1]}{T}\]
	where \(T\) is the sample period. We also know that \(q[\cdot] = CV_o[\cdot]\) so substituting: \[i[n] = \frac{C(V_o[n]-V_o[n-1])}{T}\]
	and substituting back into the original expression yields: \[V_i[n]-V_o[n]=\frac{R C V_o[n]-R C V_o[n-1]}{T}\]
	Rearranging to solve for \(V_o[n]\) yields: \[V_o[n] = \frac{T V_i[n]}{T+RC} + \frac{R C V_o[n-1]}{T+RC}\]
	Great! Now we have a way given the previous output voltage (or the initial assumption) and the input voltage at time \(n\), we can 
	determine the output voltage at time \(n\). The only thing left is to choose a \(RC\) value...wait how do we do this?
	Recall that the time constant \(RC\) and the low-pass filter cutoff frequency are related via: \[f_c = \frac{1}{2\pi RC}\]
	Looking at the terms in the equation for \(V_o[n]\) above, we can conveniently rewrite it as: \[V_o[n] = \alpha V_i[n] + (1-\alpha) V_o[n-1]\]
	where \(\alpha = \frac{T}{RC+T}\). This lets us solve for \(RC\) in terms of \(\alpha\): \[RC = T(\frac{1-\alpha}{\alpha})\]
	and then solve for alpha in terms of our desired cutoff frequency: \[\alpha = \frac{2\pi f_c T}{1+2\pi f_c T}\]
	We can now design \(RC\) based on our desired cutoff frequency.
	
	<h3> Voltage Controlled Oscillator </h3>
	Given the frequency range of outputs of the error signal (in our case -1.25MHz to 1.25MHz), the voltage controlled oscillator will proportionally adjust its frequency. To model this:
	We know we will have an error signal that will deviate from \(-\pi\) to \(\pi\) so let's divide the error by \(\pi\) to normalize the error's range from -1 to 1: \[\frac{\mathrm{error}}{\pi}\]
	We know our output should be the same frequency range of our input, which is \((-f_s/2,f_s/2)\) so we multiply the normalized error to get the VCO output frequency: \[f_{\mathrm{vco}} = \frac{\mathrm{error}}{\pi}*\frac{f_s}{2}\]
	At the phase detector we are ultimately comparing the phase of the incoming signal and not the frequency. We know our sample period, \(T\), so let's just convert this frequency to a phase change: \[\Delta \phi_{\mathrm{vco}} = 2\pi f_{\mathrm{vco}} T\]
	Substituting the previous two equations, we get the phase change: \[\Delta \phi_{\mathrm{vco}} = 2T\mathrm{error}\frac{f_s}{2}\]
	Now, we just add this phase change to the previous phase of the VCO to get the new VCO phase.

        <h1> What I Learned </h1>
        <ul> 
			<li> You can use the command <tt> rtl_sdr </tt> to get .dat files that you can read with external programs. The inputs for the command are:
			<ul>
				<li> -f : specify a frequency in HZ</li>
				<li> -s : specify the sampling rate in HZ</li>
				<li> -n : specify the number of samples </li>
				<li> -g : gain in dB </li>
				<li> -p : ppm error </li>
				<li> outputfile name : Must specify an output file to write the data to</li>
			</ul>
			The data is written in 8 bit unsigned format. 
			</li>
			<li> How to read from a directory in C using the dirent.h and sys/types.h library. You can use the <tt> opendir(char * string) </tt> command to open
			a directory and then pass the directory structure to <tt>readdir(DIR d)</tt> in order to read from the directory</li>
			<li> C cannot return an array from a function directly. There are three ways to do this:
			<ol> 
			<li> Using dynamically allocated array. I take this approach in the process_fm code. In order to output a list of files the user can read from as well
			as return that list of files, I create a 2D char array. The first dimension stores the pointers (up to 10) to each char array that can have up to 20 characters
			in the filename. </li>
			<li> Using static array </li>
			<li> Using a structure. I since modified my dynamically allocated approach to a structure-based approach so that I can also include the number of files that are readable. </li>
			<li> How to read from binary data file. The issue I was having was that I did not include the path to the binary file. Since we know the file is encoded with unsigned 8 bit integer, each
			value only takes up 1 byte. Needed to make a string concatenation function to be able to add the file path to the file name and read the binary file. </li>
			<li> The downconverted signal of the RTLSDR arrives at the ADC, so you are sampling the downconverted signal. However, this does not mean you have frequency demodulated. There are 2 parts to
			FM: upconversion and modulation. You successfully downconverted but you still have to demodulate. The downconversion brings your frequency down according to where you are tuned, so if you are tuned
			to 94MHz, you will downconvert that to 0. So if your sampling frequency is 2.4MHz, you would be able to sample -1.2MHz to 1.2MHz according to Nyquist. This is really 92.8MHz to 95.2MHz though but you just
			have to filter, decimate, and demodulate. </li>
			<li> The reason for my question about the strange characters that appear when I print the bytes is trivial. While I expected all of the values to appear in hex form, if the byte value corresponded to an ASCII
			character, the byte printed out as that ASCII character instead of the hex value. It still represents the correct binary value, but I just needed to implement a different function to convert from the binary 
			value to a decimal value. </li>
			</ol>
			
			</li>
        </ul>
        
	<h1> Radio Captures </h1>
	The following two captures were made at a 2.5MHz sampling rate. 25M samples were collected, therefore 10 sec of data. 
	<ul>
		<li> rock_capture : 94500900Hz. 0dB gain. </li>
		<li> lower freq capture : 27772000Hz. Also with 10dB gain.</li>
		<li> FMcapture1: 100122000Hz. With 40dB gain. This is from <a href=http://www.aaronscher.com/wireless_com_SDR/RTL_SDR_AM_spectrum_demod.html> here </a></li>
	</ul>
	Each of these files take up 50MB of memory. Therefore, if I had to guess, there are 2 bytes per sample: one byte for In-phase and the other for Quadrature.
	We can start with the assumption that these are time-based samples, so the first 2 bytes are from sample 1 at time 0.4 microseconds. The last sample is
	at 10 seconds.
        
        <h1> Questions </h1>
        The following questions came up while I was writing this program
        <ol>
        <li> 17JUL - How to return a multidimensional array from a function? </li>
	<li> 18JUL - How to convert from string to int</li
	<li> 19JUL - Writing a proper integer to string conversion file </li>
	<li> 19AUG - Hit a road block today in trying to code the demodulator. Realizing that there is a downconverter in the RTLSDR
	before the ADC, my samples are of the downconverted signal rather than the actual received signal itself. The question is,
	what was the downconverter frequency? Is it always what you are currently set on when you receive the broadcast? If so then 
	would everything already be FM demodulated? </li>
	<li> 21AUG - Ran into an issue today in trying to write the Python code. When looking at the ADC data (by printing out the 
	bytes type after I read bytes) there are some strange characters that I didn't expect like ~ and } { stuff like that. I was just 
	expecting some hexadecimal numbers. The thing is, I don't think this is wrong because the FM capture from the website looks the same
	(although I think I should have ran my captures with more gain). </li>
	<li> 25AUG - to avoid reading from the .dat file every time, would it be possible to save the data once it is converted from .dat to
	an int array and then just load the int array from then on? 
	</li>
        </ol>
	
	<h1> Useful Links/Sources </h1>
	<ol>
	<li> <a href=http://www.aaronscher.com/wireless_com_SDR/RTL_SDR_AM_spectrum_demod.html> MATLAB-based tutorial </a> </li>
	<li> Modern Electronic Communication, 9th Edition. Beasley and Miller. </li>
	<li> <a href=https://docs.python.org/3/library/wave.html> Python wave module </a></li>
	<li> <a href=https://docs.python.org/2/library/struct.html> Writing .wav file data </a></li>
	</ol>
    </body>
</html>
